<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radium Engine: 3D objects (a.k.a. Meshes)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
 DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
 DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
 DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="radium-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">1.5.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('develmeshes.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">3D objects (a.k.a. Meshes)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md96">Geometry types</a></li>
<li class="level1"><a href="#autotoc_md97">Colaboration between Core and Engine</a></li>
<li class="level1"><a href="#autotoc_md98">Data consistency</a></li>
<li class="level1"><a href="#autotoc_md99">Mesh creation</a><ul><li class="level2"><a href="#wedges">Wedges</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md96"></a>
Geometry types</h1>
<p>There is three kind of geometry representation included in radium source :</p>
<ol type="1">
<li>Ra::Core::Geometry::*, which handles geometry data and connectivity as a indexed vertex array. Each vertex is a unique set of position, normal, and other attributes. If indexed, faces are defined with VectorXui, where X is 1 for point, 2 for lines, 3 for triangles, and N for polygons. See inheritance diagram of <a class="el" href="structRa_1_1Core_1_1Geometry_1_1AbstractGeometry.html">Ra::Core::Geometry::AbstractGeometry</a> :<ul>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html" title="This class represents vertex + attributes per vertex. Toplogy is handled in MultiIndexedGeometry subc...">Ra::Core::Geometry::AttribArrayGeometry</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1IndexedGeometry.html" title="A single layer MultiIndexedGeometry.">Ra::Core::Geometry::IndexedGeometry</a></li>
<li>Ra::Core::Geometry::LineStrip *</li>
<li>Ra::Core::Geometry::PointCloud *</li>
<li>Ra::Core::Geometry::IndexedPointCloud *</li>
<li>Ra::Core::Geometry::LineMesh *</li>
<li>Ra::Core::Geometry::TriangleMesh *</li>
<li>Ra::Core::Geometry::PolyMesh *</li>
</ul>
</li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html">Ra::Core::Geometry::TopologicalMesh</a>, which is an half-edge data structure. A converter allows to go back and forth to <code>TriangleMesh</code> without loss of data, but during the conversion, vertices with the same position represents the same topological point (and are hence merged). <b>Soon deprecated:</b> The other vertex attributes are stored on half-edges (to manage multiple normals per 3D positions for instance). <b>New:</b> The other vertex attributes are stored on wedges. Each half-edge has one wedge index. If multiple half-edge have the same set of attributes (including vertex position) they have the same wedge index at construction. See section <a class="el" href="develmeshes.html#wedges">wedges</a> below.</li>
<li><a class="el" href="namespaceRa_1_1Engine_1_1Data.html" title="(GPU) Data representation, along with manager">Ra::Engine::Data</a>::*, which stores a Core Geometry to handle 3D data, and manages the rendering aspect of it (VAO, VBO, draw call). See inheritance diagram of <a class="el" href="classRa_1_1Engine_1_1Data_1_1AttribArrayDisplayable.html">Ra::Engine::Data::AttribArrayDisplayable</a><ul>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1Displayable.html">Ra::Engine::Data::Displayable</a></li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1AttribArrayDisplayable.html">Ra::Engine::Data::AttribArrayDisplayable</a></li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1CoreGeometryDisplayable.html" title="Template class to manage the Displayable aspect of a Core Geomertry, such as TriangleMesh.">Ra::Engine::Data::CoreGeometryDisplayable</a></li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1PointCloud.html" title="A PointCloud without indices.">Ra::Engine::Data::PointCloud</a> *</li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1IndexedGeometry.html" title="An engine mesh owning CoreGeometry, with indices.">Ra::Engine::Data::IndexedGeometry</a></li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1IndexedAttribArrayDisplayable.html">Ra::Engine::Data::IndexedAttribArrayDisplayable</a></li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1LineMesh.html" title="LineMesh, own a Core::Geometry::LineMesh.">Ra::Engine::Data::LineMesh</a> *</li>
<li><a class="el" href="classRa_1_1Engine_1_1Data_1_1Mesh.html" title="Mesh, own a Core::Geometry::TriangleMesh.">Ra::Engine::Data::Mesh</a> *</li>
<li>Ra::Engine::Data::PolyMesh *</li>
</ul>
</li>
</ol>
<p><code>*</code> : the starred classes are the one you want to instanciate, the other are more for code factoring or abstraction.</p>
<h1><a class="anchor" id="autotoc_md97"></a>
Colaboration between Core and Engine</h1>
<p>A Core Geometry can be used on its own.</p>
<p>Engine Geometry must own a Core Geometry, either set at construction, or later with loadGeometry. The Core Geometry ownership is then transfered to the Engine Geometry, and can be accessed by reference with <a class="el" href="classRa_1_1Engine_1_1Data_1_1Displayable.html#aab6e5c5ae31f270d10115062176a82ae">Ra::Engine::Data::Displayable::getAbstractGeometry</a> or Ra::Engine::Data::CoreGeometryDisplayable::getCoreGeometry</p>
<h1><a class="anchor" id="autotoc_md98"></a>
Data consistency</h1>
<p>As soon as a Core Geometry is owned by a Engine Geometry, each data update on the Core Geometry attribute trigger a observator method to mark the corresponding GPU data as dirty. On the next <a class="el" href="classRa_1_1Engine_1_1Data_1_1CoreGeometryDisplayable.html#a185171226018c59fb689efcb2154619b" title="Update (i.e. send to GPU) the buffers marked as dirty.">Ra::Engine::Data::CoreGeometryDisplayable::updateGL</a>, the dirty data will be updated on the GPU.</p>
<h1><a class="anchor" id="autotoc_md99"></a>
Mesh creation</h1>
<p><code>GeometryComponent</code> is in charge of loading a <code>GeometryData</code> and create the corresponding <code>Mesh</code>.</p>
<p>The user can add on the fly new vertex attributes to a <a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html" title="This class represents vertex + attributes per vertex. Toplogy is handled in MultiIndexedGeometry subc...">Ra::Core::Geometry::AttribArrayGeometry</a> An attribute is defined by a unique name (<a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>) and then represented as a <a class="el" href="classRa_1_1Core_1_1Utils_1_1AttribHandle.html" title="An attrib handle basically store an Index and a name.">Ra::Core::Utils::AttribHandle</a>. The type of the attribute is defined by the caller using the template parameter of the method <a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#ae1956b0396dadd84f55a12f2160e5671">Ra::Core::Geometry::AttribArrayGeometry::addAttrib</a>. To ensure consistency, it is strongly recommended to store the handle returned by the <a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#ae1956b0396dadd84f55a12f2160e5671">Ra::Core::Geometry::AttribArrayGeometry::addAttrib</a> method:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> handle1 = m.addAttrib&lt;Vector3&gt;( <span class="stringliteral">&quot;vector3_attrib&quot;</span> );</div>
</div><!-- fragment --><p>Attribute names <code>in_position</code> and <code>in_normals</code> are reserved. Note that handles to existing attributes can be retrieved by name (see <a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#aeb68d9cd8cf8c1e05886a23f0ad33c59">Ra::Core::Geometry::AttribArrayGeometry::getAttrib</a>), however the caller have to provide the type of the associate attribute. There is no type check on this access, and we recommend not to use this. We keep this method for convenience in some specific cases such as copy of attributes, however note that it might be marked as deprecated at any time.</p>
<p>There is no (in the current version) data checking, and attributes are simple <code><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>s added to the attribute manager. It's meant to be used as vector of data, such as vertices and normals, with the same size and accessed with the vertices indices. But please be aware no check nor allocation are done, so the allocation has to be performed on client side.</p>
<p>When copying a <a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html" title="This class represents vertex + attributes per vertex. Toplogy is handled in MultiIndexedGeometry subc...">Ra::Core::Geometry::AttribArrayGeometry</a> or one of its descendent class, all its attributes are copied, unless it is done through <a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a1828a9428b47dc4a3f5cebec0681fc83">Ra::Core::Geometry::AttribArrayGeometry::copyBaseGeometry</a>, for which no attribute is copied. In order to copy some/all of the attributes, the dedicated methods must be used.</p>
<p>Attribute writes must be with "lock" to ensure data syncronisation. Utility methods are provided for position and normals :</p>
<ul>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1IndexedGeometry.html#ad1fc6b57b469ef12d14f677852b8f2a8">Ra::Core::Geometry::IndexedGeometry::setIndices</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1IndexedGeometry.html#a7b980c93c40307027025d3919a948eaa">Ra::Core::Geometry::IndexedGeometry::getIndicesWithLock</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1IndexedGeometry.html#a9fd4c8118607a4a0f5ffb51716682522" title="unlock previously read write acces, notify observers of the update.">Ra::Core::Geometry::IndexedGeometry::indicesUnlock</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a887411177386edbcdc35d0c6bf78a83a" title="Set vertices.">Ra::Core::Geometry::AttribArrayGeometry::setVertices</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a7f57cb8c0c0a79c2c69bffe5b8a20357">Ra::Core::Geometry::AttribArrayGeometry::verticesWithLock</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a815c49137e348ae161fb3762f8c5b1ab" title="Release lock on vertices positions.">Ra::Core::Geometry::AttribArrayGeometry::verticesUnlock</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a646faabae9b936589fe03d8a9d2002e9" title="Set normals.">Ra::Core::Geometry::AttribArrayGeometry::setNormals</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a365e4d1e66fb093b775a17562408126c">Ra::Core::Geometry::AttribArrayGeometry::normalsWithLock</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#a71452620a83df6e6f6b995a503dc8a52" title="Release lock on vertices normals.">Ra::Core::Geometry::AttribArrayGeometry::normalsUnlock</a></li>
</ul>
<p>Others attributes are written with :</p>
<ul>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1AttribArrayGeometry.html#aeb68d9cd8cf8c1e05886a23f0ad33c59">Ra::Core::Geometry::AttribArrayGeometry::getAttrib</a> to get an attrib handle</li>
<li><a class="el" href="classRa_1_1Core_1_1Utils_1_1Attrib.html#a1aecf7dfdda7433ca789f8880b2fdb43">Ra::Core::Utils::Attrib::setData</a> to set the data directly or</li>
<li><a class="el" href="classRa_1_1Core_1_1Utils_1_1Attrib.html#a36eee2128af8869a7dafebb8fc60690f">Ra::Core::Utils::Attrib::getDataWithLock</a> to get a writable reference to the data array</li>
<li><a class="el" href="classRa_1_1Core_1_1Utils_1_1AttribBase.html#a7d1e21999ec3d5af8909d400f6cf3dfe" title="Unlock data so another one can gain write access.">Ra::Core::Utils::Attrib::unlock</a> to release the writable reference</li>
</ul>
<p>For instance </p><div class="fragment"><div class="line">    <span class="keyword">using </span>Ra::Core::Geometry::TriangleMesh;</div>
<div class="line">    TriangleMesh m;</div>
<div class="line">    TriangleMesh::PointAttribHandle::Container vertices;</div>
<div class="line">    TriangleMesh::NormalAttribHandle::Container normals;</div>
<div class="line">    TriangleMesh::IndexContainerType indices;</div>
<div class="line"> </div>
<div class="line">    vertices.push_back( { 0, 0, 0 } );</div>
<div class="line">    vertices.push_back( { 1, 0, 0 } );</div>
<div class="line">    vertices.push_back( { 0, 2, 0 } );</div>
<div class="line">    normals.push_back( { 0, 0, 1 } );</div>
<div class="line">    normals.push_back( { 0, 0, 1 } );</div>
<div class="line">    normals.push_back( { 0, 0, 1 } );</div>
<div class="line"> </div>
<div class="line">    m.setVertices( <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>( vertices ) );</div>
<div class="line">    m.setNormals( <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>( normals ) );</div>
<div class="line"> </div>
<div class="line">    m.setIndices( { { 0, 1, 2 } } );</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> handle1  = m.addAttrib&lt;Vector3&gt;( <span class="stringliteral">&quot;vector3_attrib&quot;</span> );</div>
<div class="line">    <span class="keyword">auto</span>&amp; attrib1 = m.getAttrib( handle1 );</div>
<div class="line">    <span class="keyword">auto</span>&amp; buf     = attrib1.getDataWithLock();</div>
<div class="line"> </div>
<div class="line">    buf.reserve( 3 );</div>
<div class="line">    buf.push_back( { 1, 1, 1 } );</div>
<div class="line">    buf.push_back( { 2, 2, 2 } );</div>
<div class="line">    buf.push_back( { 3, 3, 3 } );</div>
<div class="line">    attrib1.unlock();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> handle2  = m.addAttrib&lt;<span class="keywordtype">float</span>&gt;( <span class="stringliteral">&quot;float_attrib&quot;</span> );</div>
<div class="line">    <span class="keyword">auto</span>&amp; attrib2 = m.getAttrib( handle2 );</div>
<div class="line">    attrib2.setData( { 1.f, 2.f, 3.f } );</div>
<div class="line"> </div>
<div class="line">    TriangleMesh m2;</div>
<div class="line">    m2.copyBaseGeometry( m );</div>
<div class="line">    m2.copyAttributes( m, handle1 );</div>
<div class="ttc" id="amove_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a></div><div class="ttdeci">T move(T... args)</div></div>
</div><!-- fragment --><p>Other examples are provided in <a class="el" href="DrawPrimitives_8cpp_source.html">DrawPrimitives.cpp</a></p>
<h2><a class="anchor" id="wedges"></a>
Wedges</h2>
<div class="image">
<object type="image/svg+xml" data="wedges.svg" style="pointer-events: none;"></object>
<div class="caption">
Wedge concept in a nutshell.</div></div>
    <p>Wedge are built at construction by using CoreMesh vertex index (which are supposed to represent wedges). Vertices with same (exact) position are merged topologically.</p>
<p>The figure above show the basic concept of wedges for the example of vertex with color attribute (same works for normals, texture coordinates or any other attributes). a) A colored mesh, each vertex can have a different color depending on which face is considered. b) for rendering, vertex are duplicated the needed number of time. Here the center vertex is duplicated three time, while the top right one is duplicated two times. c) But for topological computation, one need to know these vertex are actually the same position, and are modified the same way. d) So the attributes (here color only) are represented as wedges associated with each coherent set of position+attributes. Here the center vertex has three wedges, while the top right vertex has two wedges. e) In the TopologicalMesh implementation, wedges are stored in an array, independently of the topology. Each half-edge has a wedge index. Half-edges that share the same wedge have the same index. During manipulation, if two wedges become the same (i.e. for the example on the figure, if we recolor the whole mesh using a single color), <b>they are not merged</b>. To merge wedges an explicit call to TopologicalMesh::mergeEqualWedges is needed. When a wedge is not referenced anymore (because referencing halfedges have been deleted), it is marked for deletation. When one call <a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html#ad0eb9c1c7711f3aa24ad612b339942bc" title="Remove deleted element from the mesh, including wedges.">Ra::Core::Geometry::TopologicalMesh::garbage_collection()</a>, the marked wedges are eventually deleted and halfedges index are updated accordingly.</p>
<p>During conversion from Core::Geometry::*Mesh to Core::Geometry::TopologicalMesh, non manifold mesh faces are not added but given to an optionally provided user defined functor (see <a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html#ab71f7b807bf20ff4b85d03a4db6961e6">Ra::Core::Geometry::TopologicalMesh::TopologicalMesh</a> and Ra::Core::Geometry::DefaultNonManifoldFaceCommand). Some meshes have multiple times the <b>same</b> vertices with <b>different</b> values for attributes inside a <b>single</b> face. This kind of situation can either raise degenerated faces, (in case of triangle mesh) or valid faces for some cases for polymesh.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>will be supported when TopologicalMesh will support PolyMesh.</dd></dl>
<p>In the latter case, the face is cleaned from the duplicated position and added to the TopologicalMesh, using the first encountered wedge value. The following figure illustrate this. <img src="wedge-degen.svg" alt="" style="pointer-events: none;" class="inline" title="Mesh to Topo conversion for faces with multiples times the same 3D position"/>    </p>
<p>TopologicalMesh methods and types related to wedges:</p>
<ul>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh_1_1WedgeData.html">Ra::Core::Geometry::TopologicalMesh::WedgeData</a> the actual wedge data, with one vector array for each of the supported types (float, Vector2, Vector3, Vector4). The order in these arrays follow the names found in getXXXAttribNames referenced below.</li>
<li>Ra::Core::Geometry::TopologicalMesh::WedgeIndex</li>
<li>Ra::Core::Geometry::TopologicalMesh::vertex_wedges</li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html#af04d4910fbeb0e3e13815cc36995dab7">Ra::Core::Geometry::TopologicalMesh::getWedgeData</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html#a749c3f1b1fd167ebfde302c2f2534a60">Ra::Core::Geometry::TopologicalMesh::setWedgeData</a></li>
<li>Ra::Core::Geometry::TopologicalMesh::getVec4AttribNames</li>
<li>Ra::Core::Geometry::TopologicalMesh::getVec3AttribNames</li>
<li>Ra::Core::Geometry::TopologicalMesh::getVec2AttribNames</li>
<li>Ra::Core::Geometry::TopologicalMesh::getFloatAttribNames</li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html#a717f9e6f73f9a9d322d34fdf45ebdedf" title="true if more than one wedge arount vertex vh, false if only one wedge">Ra::Core::Geometry::TopologicalMesh::isFeatureVertex</a></li>
<li><a class="el" href="classRa_1_1Core_1_1Geometry_1_1TopologicalMesh.html#a4f2209deb980debd0c4676c9a72c9570">Ra::Core::Geometry::TopologicalMesh::isFeatureEdge</a></li>
<li>Ra::Core::Geometry::TopologicalMesh::getWedgeIndexPph</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>To delete face, one need to call <code>Ra::Core::Geometry::TopologicalMesh::delete_face</code>, not the <code>OpenMesh</code> vanilla <code>delete_face</code></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>make OpenMesh inheritance private.</dd></dl>
<p>Use <code>Ra::Core::Geometry::TopologicalMesh::collapseWedge</code> to perform halfedge collapse (works on triangle only ...). The following figure show the nasty updates: <img src="wedge-collapse.svg" alt="" style="pointer-events: none;" class="inline" title="Halfedge collapse and wedge."/>     </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="develmanual.html">Developer manual</a></li><li class="navelem"><a class="el" href="api.html">API</a></li><li class="navelem"><a class="el" href="core.html">Core</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
