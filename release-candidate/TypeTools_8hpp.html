<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radium Engine: /home/runner/work/Radium-Engine/Radium-Engine/src/Radium-Engine/src/Headless/CLI/TypeTools.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="radium-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">1.2.24</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TypeTools_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">TypeTools.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;exception&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for TypeTools.hpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="TypeTools_8hpp__incl.svg" width="100%" height="473"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> This graph shows which files directly or indirectly include this file:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="TypeTools_8hpp__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="TypeTools_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1make__void.html">CLI::make_void&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy of std::void_t from C++17 (helper for C++11 and C++14)  <a href="structCLI_1_1make__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1is__bool.html">CLI::is_bool&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if something is bool (fail check by default)  <a href="structCLI_1_1is__bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1is__bool_3_01bool_01_4.html">CLI::is_bool&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if something is bool (true if actually a bool)  <a href="structCLI_1_1is__bool_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1is__shared__ptr.html">CLI::is_shared_ptr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if something is a shared pointer.  <a href="structCLI_1_1is__shared__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1is__shared__ptr_3_01std_1_1shared__ptr_3_01T_01_4_01_4.html">CLI::is_shared_ptr&lt; std::shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if something is a shared pointer (True if really a shared pointer)  <a href="structCLI_1_1is__shared__ptr_3_01std_1_1shared__ptr_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1is__shared__ptr_3_01const_01std_1_1shared__ptr_3_01T_01_4_01_4.html">CLI::is_shared_ptr&lt; const std::shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if something is a shared pointer (True if really a shared pointer)  <a href="structCLI_1_1is__shared__ptr_3_01const_01std_1_1shared__ptr_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1is__copyable__ptr.html">CLI::is_copyable_ptr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if something is copyable pointer.  <a href="structCLI_1_1is__copyable__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1IsMemberType.html">CLI::IsMemberType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be specialized to override the type deduction for <a class="el" href="classCLI_1_1IsMember.html" title="Verify items are in a set.">IsMember</a>.  <a href="structCLI_1_1IsMemberType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1IsMemberType_3_01const_01char_01_5_01_4.html">CLI::IsMemberType&lt; const char * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main custom type needed here is const char * should be a string.  <a href="structCLI_1_1IsMemberType_3_01const_01char_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1element__type.html">CLI::detail::element_type&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not a pointer  <a href="structCLI_1_1detail_1_1element__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1element__type_3_01T_00_01typename_01std_1_1enable__if_3_01is__copyable__p095259d742d782941ef6a8bf79b7548e.html">CLI::detail::element_type&lt; T, typename std::enable_if&lt; is_copyable_ptr&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1element__value__type.html">CLI::detail::element_value_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1pair__adaptor.html">CLI::detail::pair_adaptor&lt; T, _ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1pair__adaptor_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01typenac7f3d35561ff46242630d08443185a90.html">CLI::detail::pair_adaptor&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type::first_type, typename T::value_type::second_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">CLI::detail::is_direct_constructible&lt; T, C &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__ostreamable.html">CLI::detail::is_ostreamable&lt; T, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__istreamable.html">CLI::detail::is_istreamable&lt; T, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for input streamability.  <a href="classCLI_1_1detail_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__complex.html">CLI::detail::is_complex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for complex.  <a href="classCLI_1_1detail_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">CLI::detail::is_mutable_container&lt; T, _ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__mutable__container_3_01T_00_01conditional__t_3_01false_00_01void__t_34f912c4cf53fe26abfba2fd2b47c408d.html">CLI::detail::is_mutable_container&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type, decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().clear()), decltype(std::declval&lt; T &gt;().insert(std::declval&lt; decltype(std::declval&lt; T &gt;().end())&gt;(), std::declval&lt; const typename T::value_type &amp; &gt;()))&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__readable__container.html">CLI::detail::is_readable_container&lt; T, _ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__readable__container_3_01T_00_01conditional__t_3_01false_00_01void__t_a11f17935a0aadb8dce82cbccb9f2c68.html">CLI::detail::is_readable_container&lt; T, conditional_t&lt; false, void_t&lt; decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().begin())&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">CLI::detail::is_wrapper&lt; T, _ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__wrapper_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01typename64a0c6feb904f77c98810c843e4d2f1f.html">CLI::detail::is_wrapper&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">CLI::detail::is_tuple_like&lt; S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1wrapped__type.html">CLI::detail::wrapped_type&lt; T, def, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to get the underlying value type if it exists or use a default  <a href="structCLI_1_1detail_1_1wrapped__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1wrapped__type_3_01T_00_01def_00_01typename_01std_1_1enable__if_3_01is__wr7fdd281434af22fc0a3e380b9a3bffc8.html">CLI::detail::wrapped_type&lt; T, def, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structCLI_1_1detail_1_1wrapped__type_3_01T_00_01def_00_01typename_01std_1_1enable__if_3_01is__wr7fdd281434af22fc0a3e380b9a3bffc8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base.html">CLI::detail::type_count_base&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="structCLI_1_1detail_1_1type__count__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_9is__tuple__l80d36c9114ac17288799bef466c7bc7c.html">CLI::detail::type_count_base&lt; T, typename std::enable_if&lt;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_9is__tuple__l80d36c9114ac17288799bef466c7bc7c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__tuple__95c1a0ec6f7c1496130700c874085e8b.html">CLI::detail::type_count_base&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the base tuple size  <a href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__tuple__95c1a0ec6f7c1496130700c874085e8b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutablea4c3104627fe84803e06115cc7149e3c.html">CLI::detail::type_count_base&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type count base for containers is the <a class="el" href="structCLI_1_1detail_1_1type__count__base.html" title="This will only trigger for actual void type.">type_count_base</a> of the individual element.  <a href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutablea4c3104627fe84803e06115cc7149e3c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1subtype__count.html">CLI::detail::subtype_count&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of overloads to get the type size of an object.  <a href="structCLI_1_1detail_1_1subtype__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">CLI::detail::subtype_count_min&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declare the <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html" title="forward declare the subtype_count_min structure">subtype_count_min</a> structure  <a href="structCLI_1_1detail_1_1subtype__count__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count.html">CLI::detail::type_count&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="structCLI_1_1detail_1_1type__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_01T_e23863d22d2e4c34f6869731ca2da588.html">CLI::detail::type_count&lt; T, typename std::enable_if&lt;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_01T_e23863d22d2e4c34f6869731ca2da588.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__complex_3_01Tcc27862bfce937e7a184d4899b689962.html">CLI::detail::type_count&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for complex since it sometimes looks like a wrapper.  <a href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__complex_3_01Tcc27862bfce937e7a184d4899b689962.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutable__contb2a5be46bc2085412bb046a9416235bc.html">CLI::detail::type_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__wrapper_3_01Tafeacc1b065a285344dc61402947bdc3.html">CLI::detail::type_count&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCLI"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI.html">CLI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceCLI_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html">CLI::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a17b4ff2556876f1f42e0d585542a1578"><td class="memTemplParams" colspan="2">template&lt;bool B, class T  = void&gt; </td></tr>
<tr class="memitem:a17b4ff2556876f1f42e0d585542a1578"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">CLI::enable_if_t</a> = typename std::enable_if&lt; B, T &gt;::type</td></tr>
<tr class="separator:a17b4ff2556876f1f42e0d585542a1578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcb7870ad49a8d458c1b585e3ab364e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:abbcb7870ad49a8d458c1b585e3ab364e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI.html#abbcb7870ad49a8d458c1b585e3ab364e">CLI::void_t</a> = typename make_void&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:abbcb7870ad49a8d458c1b585e3ab364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy of std::void_t from C++17 - same reasoning as enable_if_t, it does not hurt to redefine.  <a href="namespaceCLI.html#abbcb7870ad49a8d458c1b585e3ab364e">More...</a><br /></td></tr>
<tr class="separator:abbcb7870ad49a8d458c1b585e3ab364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fcdcefcfde73ff50ae59869f047080"><td class="memTemplParams" colspan="2">template&lt;bool B, class T , class F &gt; </td></tr>
<tr class="memitem:a61fcdcefcfde73ff50ae59869f047080"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI.html#a61fcdcefcfde73ff50ae59869f047080">CLI::conditional_t</a> = typename std::conditional&lt; B, T, F &gt;::type</td></tr>
<tr class="separator:a61fcdcefcfde73ff50ae59869f047080"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af27dda5da343e609526e3dacf435b1c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">CLI::detail::enabler</a> </td></tr>
<tr class="memdesc:af27dda5da343e609526e3dacf435b1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple empty scoped class.  <a href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">More...</a><br /></td></tr>
<tr class="separator:af27dda5da343e609526e3dacf435b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">CLI::detail::from_stream</a> (const std::string &amp;istring, T &amp;obj)</td></tr>
<tr class="memdesc:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated operation to get a value from a stream.  <a href="namespaceCLI_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">More...</a><br /></td></tr>
<tr class="separator:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">CLI::detail::to_string</a> (T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</td></tr>
<tr class="memdesc:a0e94052d485636fc9f18c21009026577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (directly forward if this can become a string)  <a href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">More...</a><br /></td></tr>
<tr class="separator:a0e94052d485636fc9f18c21009026577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">CLI::detail::to_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4e5965e3013bad7369e985e2f2fd42f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from the object.  <a href="namespaceCLI_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">More...</a><br /></td></tr>
<tr class="separator:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">CLI::detail::to_string</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a9c070858740ce15aaecb1c5f04e21a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (streaming must be supported for that type)  <a href="namespaceCLI_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">More...</a><br /></td></tr>
<tr class="separator:a9c070858740ce15aaecb1c5f04e21a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">CLI::detail::checked_to_string</a> (T &amp;&amp;value) -&gt; decltype(to_string(std::forward&lt; T &gt;(value)))</td></tr>
<tr class="memdesc:a1bcb244a7701fc68da3a863b58daf615"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespaceCLI_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">More...</a><br /></td></tr>
<tr class="separator:a1bcb244a7701fc68da3a863b58daf615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">CLI::detail::checked_to_string</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:ae396058c9ea28259db0c05376bf9c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespaceCLI_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">More...</a><br /></td></tr>
<tr class="separator:ae396058c9ea28259db0c05376bf9c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">CLI::detail::value_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9a74f119a795b25c40db74ffa21d3c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string as a convertible value for arithmetic types  <a href="namespaceCLI_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">More...</a><br /></td></tr>
<tr class="separator:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">CLI::detail::value_string</a> (const T &amp;value) -&gt; decltype(to_string(value))</td></tr>
<tr class="memdesc:a130e048f492ea4619246e2f4cabaf4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">for other types just use the regular to_string function  <a href="namespaceCLI_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">More...</a><br /></td></tr>
<tr class="separator:a130e048f492ea4619246e2f4cabaf4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I==type_count_base&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">CLI::detail::tuple_type_size</a> ()</td></tr>
<tr class="memdesc:af643ce5d039d1c94f85ca05591501085"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 if the index &gt; tuple size  <a href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">More...</a><br /></td></tr>
<tr class="separator:af643ce5d039d1c94f85ca05591501085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722986055318f9f83c37749ff14c652f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:a722986055318f9f83c37749ff14c652f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I&lt; type_count_base&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type tuple_type_size() { return subtype_count&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size&lt; T, I+1 &gt;);}template&lt; typename T &gt;struct type_count&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { tuple_type_size&lt; T, 0 &gt;) };};template&lt; typename T &gt;struct subtype_count { static constexpr <a class="el" href="classint.html">int</a> value { is_mutable_container&lt; T &gt;::value ? expected_max_vector_size :type_count&lt; T &gt;::value };};template&lt; typename T, typename Enable=void &gt;struct type_count_min { static const <a class="el" href="classint.html">int</a> value { 0 };};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { type_count&lt; T &gt;::value };};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { 1 };};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { subtype_count_min&lt; typename T::value_type &gt;::value };};template&lt; typename T, std::size_t I &gt;constexpr typename std::enable_if&lt; I==type_count_base&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type tuple_type_size_min() { return 0;}template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; type_count_base&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type tuple_type_size_min() { return subtype_count_min&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;);}template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { tuple_type_size_min&lt; T, 0 &gt;) };};template&lt; typename T &gt;struct subtype_count_min { static constexpr <a class="el" href="classint.html">int</a> value { is_mutable_container&lt; T &gt;::value ?((type_count&lt; T &gt;::value&lt; expected_max_vector_size) ? type_count&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value };};template&lt; typename T, typename Enable=void &gt;struct expected_count { static const <a class="el" href="classint.html">int</a> value { 0 };};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { 1 };};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { expected_max_vector_size };};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;is_wrapper&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { expected_count&lt; typename T::value_type &gt;::value };};enum class object_category :<a class="el" href="classint.html">int</a> { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80,};template&lt; typename T, typename Enable=void &gt;struct classify_object { static constexpr object_category value { object_category::other };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, <a class="el" href="classchar.html">char</a> &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!is_bool&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::integral_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, <a class="el" href="classchar.html">char</a> &gt;::value &amp;&amp;!is_bool&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::unsigned_integral };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classchar.html">char</a> &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::char_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; is_bool&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::boolean_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::floating_point };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::string_assignable };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(type_count&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::string_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::enumeration };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::complex_number };};template&lt; typename T &gt;struct uncommon_type { using type=typename std::conditional&lt; !std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr <a class="el" href="classbool.html">bool</a> value=type::value;};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;(!is_mutable_container&lt; T &gt;::value &amp;&amp;is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value { object_category::wrapper_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;is_direct_constructible&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;is_direct_constructible&lt; T, <a class="el" href="classint.html">int</a> &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::number_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_direct_constructible&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;is_direct_constructible&lt; T, <a class="el" href="classint.html">int</a> &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::integer_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;type_count&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;is_direct_constructible&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;!is_direct_constructible&lt; T, <a class="el" href="classint.html">int</a> &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::double_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;((type_count&lt; T &gt;::value &gt;=2 &amp;&amp;!is_wrapper&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!is_direct_constructible&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;!is_direct_constructible&lt; T, <a class="el" href="classint.html">int</a> &gt;::value))&gt;::type &gt; { static constexpr object_category value { object_category::tuple_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::container_value };};template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::char_value, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;CHAR&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;INT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;UINT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;FLOAT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::enumeration, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;ENUM&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;BOOLEAN&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::complex_number, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;COMPLEX&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, detail::enabler &gt;=detail::dummy &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;TEXT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;type_count_base&lt; T &gt;::value &gt;=2, detail::enabler &gt;=detail::dummy &gt;std::string type_name();template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt;=detail::dummy &gt;std::string type_name();template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;type_count_base&lt; T &gt;::value==1, detail::enabler &gt;=detail::dummy &gt;inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;);}template&lt; typename T, std::size_t I &gt;inline typename std::enable_if&lt; I==type_count_base&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string {};}template&lt; typename T, std::size_t I &gt;inline typename std::enable_if&lt;(I&lt; type_count_base&lt; T &gt;::value), std::string &gt;::type tuple_name() { std::string str=std::string(type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;))+','+tuple_name&lt; T, I+1 &gt;);if(str.back()==',') str.pop_back();return str;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;type_count_base&lt; T &gt;::value &gt;=2, detail::enabler &gt; &gt; std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a722986055318f9f83c37749ff14c652f">CLI::detail::type_name</a> ()</td></tr>
<tr class="memdesc:a722986055318f9f83c37749ff14c652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively generate the tuple type name.  <a href="namespaceCLI_1_1detail.html#a722986055318f9f83c37749ff14c652f">More...</a><br /></td></tr>
<tr class="separator:a722986055318f9f83c37749ff14c652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a397d777acde370a61fdfc1022a97508b">CLI::detail::type_name</a> ()</td></tr>
<tr class="memdesc:a397d777acde370a61fdfc1022a97508b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type name for a type that has a value_type member  <a href="namespaceCLI_1_1detail.html#a397d777acde370a61fdfc1022a97508b">More...</a><br /></td></tr>
<tr class="separator:a397d777acde370a61fdfc1022a97508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">CLI::detail::integral_conversion</a> (const std::string &amp;input, T &amp;output) noexcept</td></tr>
<tr class="memdesc:af6685ecdb07b40a316035bb4af9b02e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an unsigned integral.  <a href="namespaceCLI_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">More...</a><br /></td></tr>
<tr class="separator:af6685ecdb07b40a316035bb4af9b02e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45abf683b881127298aa28b3c4e6cf5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">CLI::detail::to_flag_value</a> (std::string val)</td></tr>
<tr class="memdesc:af45abf683b881127298aa28b3c4e6cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a flag into an integer value typically binary flags.  <a href="namespaceCLI_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">More...</a><br /></td></tr>
<tr class="separator:af45abf683b881127298aa28b3c4e6cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af286727de86fce444325681379e2c511">CLI::detail::lexical_cast</a> (const std::string &amp;input, T &amp;output)</td></tr>
<tr class="memdesc:af286727de86fce444325681379e2c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer conversion.  <a href="namespaceCLI_1_1detail.html#af286727de86fce444325681379e2c511">More...</a><br /></td></tr>
<tr class="separator:af286727de86fce444325681379e2c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplParams" colspan="2">template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">CLI::detail::lexical_assign</a> (const std::string &amp;input, AssignTo &amp;output)</td></tr>
<tr class="memdesc:ab6647281bf64bba7b07737297ae1895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value through lexical cast operations.  <a href="namespaceCLI_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">More...</a><br /></td></tr>
<tr class="separator:ab6647281bf64bba7b07737297ae1895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a01c35a876e2917ffdc1ee618e0c06619"><td class="memItemLeft" align="right" valign="top">constexpr enabler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">CLI::detail::dummy</a> = {}</td></tr>
<tr class="memdesc:a01c35a876e2917ffdc1ee618e0c06619"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance to use in EnableIf.  <a href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">More...</a><br /></td></tr>
<tr class="separator:a01c35a876e2917ffdc1ee618e0c06619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_1577ba8040ea4e3d21120572b53f4a28.html">Headless</a></li><li class="navelem"><a class="el" href="dir_34a4d176080403972ecf681e5218a237.html">CLI</a></li><li class="navelem"><a class="el" href="TypeTools_8hpp.html">TypeTools.hpp</a></li>
    <li class="footer">Generated on Wed May 11 2022 14:40:00 for Radium Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
