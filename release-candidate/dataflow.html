<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radium Engine: Dataflow</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="radium-logo.webp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">1.5.24</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dataflow.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Dataflow</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md35">Structure and usage of the Radium::Dataflow component</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md36">Concepts of the node system</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md37">HelloGraph : your first program that uses the node system</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md38">1. Building and inspecting the graph</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md39">2. Compiling the graph and getting input/output accessors</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md40">3. Executing the graph</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md41">4. Multiple run of the graph on different input</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md42">Examples of graphs and of programming custom nodes</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md43">Graph As Node</a>
  </li>
</ul>
</div>
<div class="textblock"><p>Radium-Engine embed a node system allowing to develop computation graph using an adaptation of dataflow programming. This documentation explain the concepts used in the node system and how to develop computation graph using the Core node system and how to extend the Core node system to be used in specific Radium-Engine application or library.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Structure and usage of the Radium::Dataflow component</h1>
<p>When building the Radium-Engine libraries, the node system is available from the Radium::Dataflow component. The availability of this component in the set of built/installed libraries is managed using the <code>RADIUM_GENERATE_LIB_DATAFLOW</code> cmake option (set to <code>ON</code> by default) of the main Radium-Engine CMakeLists.txt.</p>
<p>The Radium::Dataflow component is a header-only library with is linked against three sub-components :</p>
<ul>
<li><b>DataflowCore</b> library defining the Core node system and a set Core Nodes allowing to develop several computation graph.</li>
<li><b>DataflowQtGui</b> library defining Qt based Gui elements to edit and interact with a computation graph.</li>
<li><b>DataflowRendering</b> library defining specific nodes to be used by a Graph-based renderer allowing to easily define custom renderers.</li>
</ul>
<p>When defining the CMakeLists.txt configuration file for an application/library that will build upon the node system, The RadiumDataflow component might be requested in several way :</p>
<ul>
<li><code>find_package(Radium REQUIRED COMPONENTS Dataflow)</code>. This will define the imported target <code>Radium::Dataflow</code> that gives access to all the available sub-components at once but also through imported targets <code>Radium::DataflowCore</code>, <code>Radium::DataflowQtGui</code> and <code>Radium::DataflowRendering</code>.</li>
<li><code>find_package(Radium REQUIRED COMPONENTS DataflowCore)</code>. This will define the imported target <code>Radium::DataflowCore</code> only.</li>
<li><code>find_package(Radium REQUIRED COMPONENTS DataflowQtGui)</code>. This will define the imported target <code>Radium::DataflowQtGui</code> only, with transitive dependencies on <code>Radium::DataflowCore</code>.</li>
<li><code>find_package(Radium REQUIRED COMPONENTS DataflowRendering)</code>. This will define the imported target <code>Radium::DataflowRendering</code> only, with transitive dependencies on <code>Radium::DataflowCore</code>.</li>
</ul>
<p>The targets that depends on a Dataflow components should then be configured as any target and linked against the requested dataflow component, by, e.g, adding the line <code>target_link_libraries(target_name PUBLIC Radium::Dataflow)</code> (or the only needed subcomponent).</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Concepts of the node system</h1>
<p>The node system allow to build computation graph that takes its input from some <em>data source</em> and store their results in some <em>data sink</em> after applying several <em>functions</em> on the data.</p>
<p>Computation graphs can be serialized and un-serialized in json format. The serialization process is nevertheless limited to serializable data stored on the node and it is of the responsibility of the application to manage non serializable data such as, e.g. anonymous functions (lambdas, functors, ...) dynamically defined by the application.</p>
<p>The Radium node system relies on the following concepts</p>
<ul>
<li><p class="startli"><em>Node</em> (see <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1Node.html" title="Base abstract class for all the nodes added and used by the node system.">Ra::Dataflow::Core::Node</a> for reference manual) : a node represent a function that will be executed on several strongly typed input data, defining the definition domain of the function, to produce some strongly typed output data, defining the definition co-domain of the function.</p>
<p class="startli">The input and output data are accessed through <em>ports</em> allowing to connect nodes together to form a graph.</p>
<p class="startli">The node profile is implicitly defined by its domain and co-domain.</p>
<p class="startli">A node can be specialized to be a <em>data source</em> node (empty domain) or a <em>data sink</em> node (empty co-domain). These specific nodes define the input and output of a complex <em>computation graph</em></p>
</li>
<li><p class="startli"><em>Port</em> (see <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1PortBase.html" title="Base class for nodes&#39; ports A port is a strongly typed extremity of connections between nodes.">Ra::Dataflow::Core::PortBase</a> for reference manual) : a port represent an element of the node profile and allow to build the computation graph by linking ports together, implicitly defining <em>links</em>.</p>
<p class="startli">A port gives access to a strongly typed data and, while implementing the general <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1PortBase.html" title="Base class for nodes&#39; ports A port is a strongly typed extremity of connections between nodes.">Ra::Dataflow::Core::PortBase</a> interface should be specialized to be either an input port (element of the definition domain of a node) through the instancing of the template <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1PortIn.html" title="Input port accepting data of type T.">Ra::Dataflow::Core::PortIn</a> or to an output port (element of the definition co-domain of a node) through the instancing of the template <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1PortOut.html" title="Forward PortOut classes used by getLink and reflect.">Ra::Dataflow::Core::PortOut</a>.</p>
<p class="startli">When a node executes its function, it takes its parameter from its input ports and set the result on the output port.</p>
<p class="startli">An output port can be connected to an input port of the same <em>DataType</em> to build the computation graph.</p>
</li>
<li><p class="startli"><em>Graph</em> (see <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html" title="Represent a set of connected nodes that define a Direct Acyclic Computational Graph Ownership of node...">Ra::Dataflow::Core::DataflowGraph</a> for reference manual) : a graph is a set of node connected through their ports so that they define a direct acyclic graph (DAG) representing a complex function. The DAG represents connections from some <em>data source</em> nodes to some <em>data sink</em> nodes through</p>
<p class="startli">Once built by adding nodes and links, a graph should be <em>compiled</em> so that the system verify its validity (DAG, types, connections, ...).</p>
<p class="startli">Once compiled, a graph can be <em>executed</em>. The input data of the computation graph should be set on the available <em>data sources</em> of the graph and the results fetched from the <em>data sinks</em>.</p>
<p class="startli">As a graph can be used as a node (a sub graph) in any other graph. When doing this, all <em>data sources</em> and <em>data sinks</em> nodes are associated with <em>interface ports</em> and these interface ports are added as <em>input</em> or <em>output</em> ports on the graph so that links can be defined using these ports.</p>
<p class="startli"><em>input</em> and <em>output</em> ports of a graph can also be accessed directly from the application using <em>data setters</em> and <em>data getters</em> fetched from the graph. These <em>data setters</em> and <em>data getters</em> allows to use any graph without the need to know explicitly their <em>data sources</em> and <em>data sinks</em> nor defining ports to be linked with the <em>input</em> and <em>output</em> ports of the graph.</p>
</li>
<li><p class="startli"><em>Factories</em> (see <a class="el" href="namespaceRa_1_1Dataflow_1_1Core_1_1NodeFactoriesManager.html">Ra::Dataflow::Core::NodeFactoriesManager</a> for reference manual) : the serialization of a graph output a set of json object describing the graph. If serialization is always possible, care must be taken for the system to manage un-serilization of any nodes.</p>
<p class="startli">When serializing a graph, the json representing a node contains the type (the name of the concrete C++ class) of the node and several other properties of the node system. When un-serializing a graph, nodes will be automatically instanced from their type. The instantiation of a node is made using services offered by node factories and associated to the node type. So, in order to be un-serializable, each node must register its type to a factory and each graph must refer to the factories used to instantiate its node.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md37"></a>
HelloGraph : your first program that uses the node system</h2>
<p>The example application examples/HelloGraph shows how to define a computation graph to apply filtering on a collection. In this example, whose code is detailed below, the following graph is built and executed using different input data.</p>
<div class="image">
<img src="HelloGraph.png" alt=""/>
<div class="caption">
HelloGraph computation graph</div></div>
    <p>This graphs has two inputs, corresponding to the two <b>Source&lt; ... &gt;</b> nodes. These input will deliver to the computation graph :</p>
<ul>
<li>from a <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1Sources_1_1SingleDataSourceNode.html" title="Base class for nodes that will give access to some input data to the graph. This class can be used to...">Ra::Dataflow::Core::Sources::SingleDataSourceNode</a>, a vector of scalars, whose container type is <a class="el" href="classRa_1_1Core_1_1VectorArray.html" title="This class implements ContainerIntrospectionInterface for AlignedStdVector.">Ra::Core::VectorArray</a> (abridged here as a RaVector) and value type is <em>Scalar</em> (float in the default Radium-Engine configuration),</li>
<li>from a <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1Sources_1_1FunctionSourceNode.html" title="Node that deliver a std::function&lt;R( Args... )}}&gt;">Ra::Dataflow::Core::Sources::FunctionSourceNode</a> a predicate whose type is <em>std::function&lt;bool(float const&amp;)&gt;</em> which returns <em>true</em> if its parameter is valid according to some decision process.</li>
</ul>
<p>These two <em>sources</em> are linked to the input of a <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1Functionals_1_1FilterNode.html" title="Filter on iterable collection.">Ra::Dataflow::Core::Functionals::FilterNode</a>, here represented by the <b>Filter&lt; ... &gt;</b> node. This node select from its <b>in</b> input only the values validated by the predicate <b>f</b> and built its output <b>out</b> with these values.</p>
<p>The result of this filtering is linked to the graph output, corresponding to the <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1Sinks_1_1SinkNode.html" title="Base class for nodes that will store the result of a computation graph.">Ra::Dataflow::Core::Sinks::SinkNode</a> <b>Sink&lt; ... &gt;</b>.</p>
<p>Once the graph is built and compile, the HelloGraph application sent different input to the graph and print the result of the computation.</p>
<p>To develop such an application, the following should be done</p>
<h2><a class="anchor" id="autotoc_md38"></a>
1. Building and inspecting the graph</h2>
<p>First, an object of type <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html" title="Represent a set of connected nodes that define a Direct Acyclic Computational Graph Ownership of node...">Ra::Dataflow::Core::DataflowGraph</a> is instanced : </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html">DataflowGraph</a> g { <span class="stringliteral">&quot;helloGraph&quot;</span> };</div>
</div><!-- fragment --><p>Then, the nodes are instanced and added to the graph </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> sourceNode    = g.<a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html#a16cdfd7a2236490f426551aaaa2ecc14">add_node</a>&lt;<a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1Sources_1_1SingleDataSourceNode.html">Sources::SingleDataSourceNode&lt;RaVector&gt;</a>&gt;( <span class="stringliteral">&quot;Source&quot;</span> );</div>
<div class="line">    <span class="keyword">auto</span> predicateNode = g.add_node&lt;Sources::ScalarUnaryPredicateSource&gt;( <span class="stringliteral">&quot;Selector&quot;</span> );</div>
<div class="line">    <span class="keyword">auto</span> filterNode    = g.add_node&lt;<a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1Functionals_1_1FilterNode.html">Functionals::FilterNode&lt;RaVector&gt;</a>&gt;( <span class="stringliteral">&quot;Filter&quot;</span> );</div>
<div class="line">    <span class="keyword">auto</span> sinkNode      = g.add_node&lt;<a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1Sinks_1_1SinkNode.html">Sinks::SinkNode&lt;RaVector&gt;</a>&gt;( <span class="stringliteral">&quot;Sink&quot;</span> );</div>
</div><!-- fragment --><p>Links between ports are added to the graph, and if an error is detected, due to e.g. port type incompatiblitiy, it is reported </p><div class="fragment"><div class="line">    <span class="comment">// link using nodes port, with compile time type check</span></div>
<div class="line">    <span class="comment">// node belongship to the graph is checked at runtime</span></div>
<div class="line">    <span class="keywordflow">if</span> ( !g.add_link( sourceNode-&gt;port_out_to(), filterNode-&gt;port_in_data() ) ) { <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/utility/program/abort.html">std::abort</a>(); }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// link with port names, all runtime check</span></div>
<div class="line">    <span class="keywordflow">if</span> ( !g.add_link( predicateNode, <span class="stringliteral">&quot;to&quot;</span>, filterNode, <span class="stringliteral">&quot;predicate&quot;</span> ) ) { <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/utility/program/abort.html">std::abort</a>(); }</div>
<div class="line">    <span class="comment">// one can also link using node index, it depends on node init, so be sure to have the right</span></div>
<div class="line">    <span class="comment">// index</span></div>
<div class="line">    <span class="comment">// Functional Port &quot;out&quot; as index 0, and Sink &quot;from&quot; is 0 also</span></div>
<div class="line">    <span class="keywordflow">if</span> ( !g.add_link( filterNode, Node::PortIndex { 0 }, sinkNode, Node::PortIndex { 0 } ) ) {</div>
<div class="line">        <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/utility/program/abort.html">std::abort</a>();</div>
<div class="line">    }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
2. Compiling the graph and getting input/output accessors</h2>
<p>In order to use the graph as a function acting on its input, it should be first compiled by </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> ( !g.compile() ) {</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot; compilation failed&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>If the compilation success the graph inputs can be set either using node return by <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html#a16cdfd7a2236490f426551aaaa2ecc14" title="Adds a node to the graph.">Ra::Dataflow::Core::DataflowGraph::add_node</a>, or getting the node from the graph with <a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html#a9235835689b87583a27da6760edff10b">Ra::Dataflow::Core::DataflowGraph::node</a> </p><div class="fragment"><div class="line">    RaVector test {</div>
<div class="line">        0.0_ra, 1.0_ra, 0.1_ra, 0.9_ra, 0.2_ra, 0.8_ra, 0.3_ra, 0.7_ra, 0.4_ra, 0.6_ra, 0.5_ra };</div>
<div class="line">    g.node&lt;<a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1Sources_1_1SingleDataSourceNode.html">Sources::SingleDataSourceNode&lt;RaVector&gt;</a>&gt;( <span class="stringliteral">&quot;Source&quot;</span> )-&gt;set_data( test );</div>
<div class="line"> </div>
<div class="line">    Sources::ScalarUnaryPredicateSource::function_type pred = []( Scalar x ) { <span class="keywordflow">return</span> x &lt; 0.5; };</div>
<div class="line">    predicateNode-&gt;<a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1Sources_1_1SingleDataSourceNode.html#a6460585a7089517eb4fd3f87da92b72a">set_data</a>( pred );</div>
</div><!-- fragment --><p>Here, the accessor <code>input</code> allows to set the pointer on the <code>RaVector</code> to be processed while the accessor <code>selector</code> allows to set the predicate to evaluate when filtering the collection. This predicates select values les than <code>0.5</code></p>
<p>The accessor <code>output</code> will allow, once the graph is executed, to get a reference to or to copy the resulting values.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
3. Executing the graph</h2>
<p>Once the input data are available (in this example, the <code>test</code> vector is filled with 10 random values between 0 and 1), the graph can be executed and a reference to the resulting vector can be fetched using </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> ( !g.execute() ) {</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;execution failed!\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md41"></a>
4. Multiple run of the graph on different input</h2>
<p>Data setters copy values to the nodes, but getters return a reference, hence results are uptodate when running the graph process again. </p><div class="fragment"><div class="line">    Sources::ScalarUnaryPredicateSource::function_type predbig = []( Scalar x ) { <span class="keywordflow">return</span> x &gt; 0.5; };</div>
<div class="line">    predicateNode-&gt;<a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1Sources_1_1SingleDataSourceNode.html#a6460585a7089517eb4fd3f87da92b72a">set_data</a>( predbig );</div>
<div class="line"> </div>
<div class="line">    g.execute();</div>
<div class="line">    <span class="comment">// since result is a ref to node&#39;s output, no need to get it again</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Output values after second execution: &quot;</span> &lt;&lt; result.size() &lt;&lt; <span class="stringliteral">&quot;\n\t&quot;</span>;</div>
<div class="line">    <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/algorithm/copy.html">std::copy</a>( result.begin(), result.end(), <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/iterator/ostream_iterator.html">std::ostream_iterator&lt;Scalar&gt;</a>( <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a>, <span class="stringliteral">&quot; &quot;</span> ) );</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md42"></a>
Examples of graphs and of programming custom nodes</h1>
<p>The unittests developed alongside the Radium::Dataflow component, and located in the directory <code>tests/unittest/Dataflow/</code> of the Radium-Engine source tree, can be used to learn the following :</p>
<ul>
<li><a class="el" href="sourcesandsinks_8cpp_source.html">sourcesandsinks.cpp</a> : shows the default supported types for sources and sinks node.</li>
<li><a class="el" href="nodes_8cpp_source.html">nodes.cpp</a> : shows the development of a more complex graph implementing transform/reduce on several collections using different reduction operators.</li>
<li>graphinspect.cpp : shows the way a graph can be inspected to discover its structure.</li>
<li><a class="el" href="serialization_8cpp_source.html">serialization.cpp</a> : shows to save/load a graph from a json file and use it in an application.</li>
<li><a class="el" href="customnodes_8cpp_source.html">customnodes.cpp</a> : shows how it is simple to develop your own node type (in C++) and use your nodes alongside standard nodes. <div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>FilterSelector final : <span class="keyword">public</span> <a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1Node.html">Node</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>function_type = <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt;bool( <span class="keyword">const</span> T&amp; )&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> FilterSelector( <span class="keyword">const</span> <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; name ) : FilterSelector( name, node_typename() ) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classCustoms_1_1FilterSelector.html#a063d5e621ab6d0e9f0912b852e74fbed">execute</a>()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// since init with default value, always has_data</span></div>
<div class="line">        REQUIRE( m_portName-&gt;has_data() );</div>
<div class="line">        m_nameOut-&gt;set_data( &amp;m_portName-&gt;data() );</div>
<div class="line">        m_currentFunction = m_functions.at( m_portName-&gt;data() );</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="classCustoms_1_1FilterSelector.html#a329710c76f759e1f8033889449cd5604">fromJsonInternal</a>( <span class="keyword">const</span> nlohmann::json&amp; data )<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// no need to have fallback, since json is ok.</span></div>
<div class="line">        REQUIRE( data.contains( <span class="stringliteral">&quot;operator&quot;</span> ) );</div>
<div class="line">        m_portName-&gt;set_default_value( <span class="stringliteral">&quot;true&quot;</span> );</div>
<div class="line">        REQUIRE( data.contains( <span class="stringliteral">&quot;threshold&quot;</span> ) );</div>
<div class="line">        m_portThreshold-&gt;set_default_value( data[<span class="stringliteral">&quot;threshold&quot;</span>] );</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classCustoms_1_1FilterSelector.html#a4d16e70e995a3f7e74395a27160a08a5">toJsonInternal</a>( nlohmann::json&amp; data )<span class="keyword"> const override </span>{</div>
<div class="line">        data[<span class="stringliteral">&quot;operator&quot;</span>]  = m_portName-&gt;data();</div>
<div class="line">        data[<span class="stringliteral">&quot;threshold&quot;</span>] = m_portThreshold-&gt;data();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; node_typename() {</div>
<div class="line">        <span class="keyword">static</span> <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> demangledTypeName =</div>
<div class="line">            <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> { <span class="stringliteral">&quot;FilterSelector&lt;&quot;</span> } + Ra::Core::Utils::simplifiedDemangledType&lt;T&gt;() + <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> demangledTypeName;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    FilterSelector( <span class="keyword">const</span> <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; instanceName, <span class="keyword">const</span> <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; typeName ) :</div>
<div class="line">        <a class="code hl_class" href="classRa_1_1Dataflow_1_1Core_1_1Node.html">Node</a>( instanceName, typeName ) {}</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/map.html">std::map&lt;std::string, function_type&gt;</a> m_functions {</div>
<div class="line">        { <span class="stringliteral">&quot;true&quot;</span>, []( <span class="keyword">const</span> T&amp; ) { <span class="keywordflow">return</span> <span class="keyword">true</span>; } },</div>
<div class="line">        { <span class="stringliteral">&quot;false&quot;</span>, []( <span class="keyword">const</span> T&amp; ) { <span class="keywordflow">return</span> <span class="keyword">false</span>; } },</div>
<div class="line">        { <span class="stringliteral">&quot;&lt;&quot;</span>, [<span class="keyword">this</span>]( <span class="keyword">const</span> T&amp; v ) { <span class="keywordflow">return</span> v &lt; this-&gt;m_portThreshold-&gt;data(); } },</div>
<div class="line">        { <span class="stringliteral">&quot;&gt;&quot;</span>, [<span class="keyword">this</span>]( <span class="keyword">const</span> T&amp; v ) { <span class="keywordflow">return</span> v &gt; this-&gt;m_portThreshold-&gt;data(); } } };</div>
<div class="line"> </div>
<div class="line">    function_type m_currentFunction = m_functions[<span class="stringliteral">&quot;true&quot;</span>];</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">PortOutPtr&lt;function_type&gt;</a> m_operatourOut {</div>
<div class="line">        <a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1Node.html#a0ab078d831c7607f5e075744386e0210">add_output&lt;function_type&gt;</a>( &amp;m_currentFunction, <span class="stringliteral">&quot;f&quot;</span> ) };</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">PortOutPtr&lt;std::string&gt;</a> m_nameOut { <a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1Node.html#a0ab078d831c7607f5e075744386e0210">add_output&lt;std::string&gt;</a>( <span class="stringliteral">&quot;name&quot;</span> ) };</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">PortInPtr&lt;std::string&gt;</a> m_portName { <a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1Node.html#a393baaa0eb2e0f1a89371efbcb72f925">add_input&lt;std::string&gt;</a>( <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;true&quot;</span> ) };</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">PortInPtr&lt;T&gt;</a> m_portThreshold { <a class="code hl_function" href="classRa_1_1Dataflow_1_1Core_1_1Node.html#a393baaa0eb2e0f1a89371efbcb72f925">add_input&lt;T&gt;</a>( <span class="stringliteral">&quot;threshold&quot;</span>, T {} ) };</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md43"></a>
Graph As Node</h1>
<p>A graph can use another graph as node. The inner graph must have input/output nodes to expose input/output ports. Related methods :</p>
<ul>
<li><a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html#afcd31a19614d373531af3c237c30c39b" title="Create (if not already created) input/output node of the graph, and fills graph input/output.">Ra::Dataflow::Core::DataflowGraph::add_input_output_nodes()</a></li>
<li><a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html#a995fa90fc32a29a8107773616ba2f8c3" title="fill input and output ports of graph from its input and output nodes if exists.">Ra::Dataflow::Core::DataflowGraph::generate_ports()</a></li>
<li><a class="el" href="classRa_1_1Dataflow_1_1Core_1_1DataflowGraph.html#a9d85ecc142747e8ef3910ad1bf42ba8a" title="Removes unsused (unlinked) input/output ports.">Ra::Dataflow::Core::DataflowGraph::remove_unlinked_input_output_ports()</a></li>
</ul>
<p><img src="graph_as_node_outter.png" alt="" class="inline" title="A graph can use another graph as node"/>    </p>
<p><img src="graph_as_node_inner.png" alt="" class="inline" title="The inner graph must have input/output nodes to expose input/output ports"/>     </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="conceptsmanual.html">Radium Concepts</a></li><li class="navelem"><a class="el" href="api.html">API</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
