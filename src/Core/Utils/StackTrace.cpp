#include <Core/Utils/StackTrace.hpp>
#include <cxxabi.h>
#include <dlfcn.h>
#include <execinfo.h>
#include <ostream>
#include <radium_backtrace.h> // for backtrace, generated by cmake
#include <stdio.h>
#include <stdlib.h>

namespace Ra {
namespace Core {
namespace Utils {

std::string StackTrace( int skip ) {
#ifdef HAS_BACKTRACE
    void* callstack[128];
    const int nMaxFrames = sizeof( callstack ) / sizeof( callstack[0] );
    char buf[1024];
    int nFrames = backtrace( callstack, nMaxFrames );

    std::ostringstream trace_buf;
    for ( int i = skip; i < nFrames; i++ ) {
        Dl_info info;
        if ( dladdr( callstack[i], &info ) ) {
            char* demangled = nullptr;
            int status;
            demangled = abi::__cxa_demangle( info.dli_sname, NULL, 0, &status );
            snprintf( buf,
                      sizeof( buf ),
                      "%-3d %*0p %s + %td\n",
                      i,
                      int( 2 + sizeof( void* ) * 2 ),
                      callstack[i],
                      status == 0 ? demangled : info.dli_sname,
                      (char*)callstack[i] - (char*)info.dli_saddr );
            free( demangled );
        }
        else {
            snprintf( buf,
                      sizeof( buf ),
                      "%-3d %*0p\n",
                      i,
                      int( 2 + sizeof( void* ) * 2 ),
                      callstack[i] );
        }
        trace_buf << buf;
    }
    if ( nFrames == nMaxFrames ) trace_buf << "  [truncated]\n";
    return trace_buf.str();
#else
    return "Execution stack trace not available.";
#endif
}

} // namespace Utils
} // namespace Core
} // namespace Ra
